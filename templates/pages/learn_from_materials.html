<!-- 从资料学习页面 - 像素级还原笔记.html的布局 -->
<style>
    /* 拖放样式优化 */
    .drag-over {
        border: 2px dashed #32C77F !important;
        background-color: rgba(50, 199, 127, 0.1) !important;
    }
    
    .dragging {
        opacity: 0.5;
        transform: rotate(2deg);
        transition: all 0.2s ease;
    }
    
    /* 文件树项目样式 - 与笔记.html保持一致 */
    .file-item .flex:hover, .folder-item .flex:hover {
        background-color: #F2F0ED; /* 使用bg-light-gray */
        transition: background-color 0.2s ease;
    }
    
    .file-item .flex.selected, .folder-item .flex.selected {
        background-color: #E2F2EB; /* 使用bg-light-green */
        border-left: 3px solid #32C77F; /* 使用primary色 */
    }
    
    /* 右键菜单动画 */
    #context-menu {
        animation: fadeInScale 0.15s ease-out;
        transform-origin: top left;
    }
    
    @keyframes fadeInScale {
        from {
            opacity: 0;
            transform: scale(0.95);
        }
        to {
            opacity: 1;
            transform: scale(1);
        }
    }
    
    /* 知识点卡片样式 - 与笔记.html保持一致 */
    .knowledge-card {
        transition: all 0.2s ease;
        border-left: 4px solid transparent;
    }
    
    .knowledge-card:hover {
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        border-left-color: #32C77F; /* 使用primary色 */
    }
    
    /* 编辑器样式 */
    #markdown-editor {
        font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
        line-height: 1.6;
        tab-size: 4;
    }
    
    #markdown-editor:focus {
        outline: none;
        box-shadow: inset 0 0 0 2px #32C77F; /* 使用primary色 */
    }
    
    /* 加载动画 */
    .loading-spinner {
        animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
        from { transform: rotate(0deg); }
        to { transform: rotate(360deg); }
    }
    
    /* 按钮禁用状态 */
    button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }
</style>

<!-- 主内容区域 - 完全按照笔记.html的三栏布局 -->
<div class="flex-1 flex bg-bg-light-blue-gray" id="main-content">
    <!-- 左侧文件结构面板 - 像素级还原笔记.html -->
    <div class="w-1/4 bg-white border-r border-gray-200 p-4 flex flex-col transition-all duration-300" id="file-structure">
        <div class="flex justify-between items-center mb-4">
            <h2 class="text-lg font-semibold text-text-dark-brown">文件结构</h2>
            <div class="space-x-2">
                <button class="text-text-gray hover:text-primary" onclick="createNewFolder()">
                    <span class="material-icons-outlined">create_new_folder</span>
                </button>
                <button class="text-text-gray hover:text-primary" onclick="createNewNote()">
                    <span class="material-icons-outlined">note_add</span>
                </button>
            </div>
        </div>
        <div class="flex-1 overflow-y-auto pr-2">
            <!-- 加载指示器 -->
            <div id="loading-indicator" class="flex items-center justify-center py-8">
                <div class="loading-spinner w-6 h-6 border-2 border-primary border-t-transparent rounded-full"></div>
                <span class="ml-2 text-text-medium-brown">加载中...</span>
            </div>
            <!-- 文件树容器 -->
            <ul class="space-y-1" id="file-tree">
                <!-- 文件树将在这里动态生成，格式与笔记.html保持一致 -->
            </ul>
        </div>
    </div>
    
    <!-- 中间主内容区域 - 完全按照笔记.html的布局 -->
    <main class="flex-1 p-6 flex flex-col">
        <header class="flex justify-between items-center mb-4">
            <h2 class="text-2xl font-bold text-text-dark-brown" id="current-file-title">选择一个文件开始学习</h2>
            <div class="flex items-center space-x-2">
                <button id="preview-btn" class="flex items-center bg-white border border-gray-300 px-3 py-1.5 rounded-lg text-text-gray hover:bg-gray-100" onclick="switchToPreview()">
                    <span class="material-icons-outlined text-sm mr-1">visibility</span>
                    <span>预览</span>
                </button>
                <button id="edit-btn" class="flex items-center bg-primary text-white px-3 py-1.5 rounded-lg hover:bg-green-600" onclick="switchToEdit()">
                    <span class="material-icons-outlined text-sm mr-1">edit</span>
                    <span>编辑</span>
                </button>
            </div>
        </header>
        <div class="flex-1 bg-white rounded-xl shadow-sm p-6 overflow-y-auto">
            <!-- 预览模式 -->
            <div id="preview-content" class="prose max-w-none">
                <div class="text-center py-16 text-gray-500">
                    <span class="material-icons-outlined text-6xl mb-4">description</span>
                    <h3 class="text-xl font-medium mb-2">欢迎使用从资料学习</h3>
                    <p>请从左侧文件树中选择一个Markdown文件开始学习</p>
                </div>
            </div>
            <!-- 编辑模式 -->
            <div id="edit-content" class="hidden h-full">
                <textarea id="markdown-editor" class="w-full h-full border-none resize-none p-4" placeholder="在这里编写Markdown内容..."></textarea>
                <div class="flex justify-end mt-4 space-x-2">
                    <button onclick="saveMarkdownFile()" class="bg-primary text-white px-4 py-2 rounded-lg hover:bg-green-600">
                        <span class="material-icons-outlined text-sm mr-1">save</span>
                        保存
                    </button>
                </div>
            </div>
        </div>
    </main>
    
    <!-- 右侧知识点面板 - 完全按照笔记.html的布局 -->
    <aside class="w-1/5 bg-white border-l border-gray-200 p-4 flex flex-col">
        <h2 class="text-lg font-semibold text-text-dark-brown mb-4">知识点列表</h2>
        <div class="flex-1 overflow-y-auto space-y-3" id="knowledge-points">
            <div class="bg-bg-light-green p-3 rounded-lg cursor-pointer hover:shadow-md transition-shadow knowledge-card">
                <h3 class="font-semibold text-primary">兴趣驱动</h3>
                <p class="text-sm text-text-medium-brown mt-1">学习的核心动力来源，提高主动性。</p>
            </div>
            <div class="bg-bg-light-gray p-3 rounded-lg cursor-pointer hover:shadow-md transition-shadow knowledge-card">
                <h3 class="font-semibold text-text-dark-brown">积极反馈</h3>
                <p class="text-sm text-text-medium-brown mt-1">通过奖励机制巩固学习成果，提升动机。</p>
            </div>
            <div class="bg-bg-light-gray p-3 rounded-lg cursor-pointer hover:shadow-md transition-shadow knowledge-card">
                <h3 class="font-semibold text-text-dark-brown">番茄工作法</h3>
                <p class="text-sm text-text-medium-brown mt-1">一种时间管理方法，用于保持专注。</p>
            </div>
        </div>
        <div class="mt-4 pt-4 border-t border-gray-200">
            <button onclick="extractKnowledgePoints()" class="w-full bg-primary text-white py-2 px-4 rounded-lg hover:bg-green-600 flex items-center justify-center">
                <span class="material-icons-outlined text-sm mr-1">psychology</span>
                提取知识点
            </button>
        </div>
    </aside>
</div>

<!-- 调试面板 -->
<div id="debug-panel" class="fixed bottom-4 right-4 w-96 bg-white border border-gray-300 rounded-lg shadow-lg z-50" style="display: none;">
    <div class="flex justify-between items-center p-3 border-b border-gray-200">
        <h4 class="font-bold text-gray-700">调试信息</h4>
        <button onclick="toggleDebugPanel()" class="text-gray-500 hover:text-gray-700">×</button>
    </div>
    <div id="debug-content" class="p-3 text-xs font-mono text-gray-600 max-h-60 overflow-y-auto whitespace-pre-wrap"></div>
</div>

<script>
    // 使用IIFE（立即调用函数表达式）创建独立作用域，避免重复声明
    (function() {
    // --- 调试代码开始 ---
    // 前端日志记录数组
    let frontendLogs = [];
    
    function debugLog(message) {
        const timestamp = new Date().toISOString();
        const logEntry = `${timestamp} - INFO - ${message}`;
        
        // 添加到日志数组
        frontendLogs.push(logEntry);
        
        // 显示在调试面板
        const debugContent = document.getElementById('debug-content');
        if (debugContent) {
            const displayTime = new Date().toLocaleTimeString();
            debugContent.textContent += `[${displayTime}] ${message}\n`;
            debugContent.scrollTop = debugContent.scrollHeight;
        }
        console.log(message);
        
        // 发送到Python后端记录到文件
        if (window.bridge && window.bridge.logFrontendMessage) {
            try {
                window.bridge.logFrontendMessage(logEntry);
            } catch (e) {
                console.warn('无法发送日志到后端:', e);
            }
        }
    }

    function debugError(message) {
        const timestamp = new Date().toISOString();
        const logEntry = `${timestamp} - ERROR - ${message}`;
        
        // 添加到日志数组
        frontendLogs.push(logEntry);
        
        // 显示在调试面板
        const debugContent = document.getElementById('debug-content');
        if (debugContent) {
            const displayTime = new Date().toLocaleTimeString();
            debugContent.textContent += `[${displayTime}] ERROR: ${message}\n`;
            debugContent.scrollTop = debugContent.scrollHeight;
        }
        console.error(message);
        
        // 发送到Python后端记录到文件
        if (window.bridge && window.bridge.logFrontendMessage) {
            try {
                window.bridge.logFrontendMessage(logEntry);
            } catch (e) {
                console.warn('无法发送错误日志到后端:', e);
            }
        }
    }
    
    // 导出前端日志的函数
    function exportFrontendLogs() {
        return frontendLogs.join('\n');
    }

    function toggleDebugPanel() {
        const panel = document.getElementById('debug-panel');
        if (panel) {
            panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
        }
    }

    function showDebugPanel() {
        const panel = document.getElementById('debug-panel');
        if (panel) {
            panel.style.display = 'block';
        }
    }
    // --- 调试代码结束 ---
    
    debugLog('从资料学习页面脚本加载');
    debugLog('当前时间: ' + new Date().toLocaleTimeString());
    debugLog('document.readyState: ' + document.readyState);
    
    // 调试WebChannel状态
    debugLog('当前window对象: ' + typeof window);
    debugLog('当前bridge对象: ' + (window.bridge ? 'exists' : 'undefined'));
    debugLog('Qt对象: ' + (window.qt ? 'exists' : 'undefined'));
    debugLog('QWebChannel类型: ' + typeof QWebChannel);
    
    // 隐藏全局header，因为我们有自己的header
    const globalHeader = document.querySelector('header');
    if (globalHeader && globalHeader.querySelector('#page-title')) {
        globalHeader.style.display = 'none';
        debugLog('已隐藏全局header');
    }
    
    // 监听WebChannel连接事件
    if (window.qt && window.qt.webChannelTransport) {
        debugLog('WebChannel transport 可用');
    } else {
        debugLog('WebChannel transport 不可用');
    }
    
    // 全局变量
    let currentFilePath = null;
    let currentMode = 'preview'; // 'preview' or 'edit'
    let selectedTreeItem = null; // 当前选中的树节点
    
    // 页面初始化函数
    function initializePage() {
        debugLog('🚀 页面初始化开始');
        showDebugPanel(); // 页面加载时自动显示调试面板
        
        // 如果bridge已经通过base.html提前加载好了，直接开始
        if (window.bridge && typeof window.bridge.getFileStructure === 'function') {
            debugLog('✅ Bridge已可用，直接加载文件结构');
            loadFileStructure();
            return;
        }
        
        // 否则，等待WebChannel初始化
        if (typeof QWebChannel !== 'undefined' && window.qt && window.qt.webChannelTransport) {
            debugLog('🔄 开始WebChannel初始化');
            initializeWebChannel();
        } else {
            debugLog('⏰ 延迟500ms后重试初始化');
            // 兜底，延迟后再次尝试初始化
            setTimeout(initializeWebChannel, 500);
        }
    }
    
    // 页面初始化 - 多种方式确保执行
    document.addEventListener('DOMContentLoaded', initializePage);
    
    // 如果DOMContentLoaded已经触发，立即执行
    if (document.readyState === 'loading') {
        debugLog('📄 文档正在加载，等待DOMContentLoaded');
    } else {
        debugLog('📄 文档已加载完成，立即初始化');
        initializePage();
    }
    
    // 初始化WebChannel连接
    function initializeWebChannel() {
        debugLog('🚀 开始初始化WebChannel连接');
        
        if (typeof QWebChannel !== 'undefined' && window.qt && window.qt.webChannelTransport) {
            debugLog('✅ QWebChannel和transport都可用');
            
            new QWebChannel(window.qt.webChannelTransport, function(channel) {
                debugLog('🎉 WebChannel连接成功！');
                debugLog('📋 Channel对象: exists');
                debugLog('📋 Channel.objects: ' + (channel.objects ? 'exists' : 'undefined'));
                
                window.bridge = channel.objects.bridge;
                debugLog('🔗 Bridge对象设置完成: ' + (window.bridge ? 'success' : 'failed'));
                
                if (window.bridge) {
                    debugLog('✅ Bridge对象可用，开始加载文件结构');
                    try {
                        const methods = Object.getOwnPropertyNames(window.bridge);
                        debugLog('📋 Bridge方法列表: ' + methods.join(', '));
                    } catch (e) {
                        debugLog('📋 无法获取Bridge方法列表: ' + e.message);
                    }
                    loadFileStructure();
                } else {
                    debugError('❌ Bridge对象不可用');
                    showError('WebChannel连接失败：bridge对象不可用');
                }
            });
        } else {
            debugError('❌ WebChannel环境不完整');
            debugLog('  - QWebChannel: ' + typeof QWebChannel);
            debugLog('  - window.qt: ' + (window.qt ? 'exists' : 'undefined'));
            debugLog('  - webChannelTransport: ' + (window.qt && window.qt.webChannelTransport ? 'exists' : 'undefined'));
            
            // 直接尝试加载，可能bridge已经可用
            if (window.bridge) {
                debugLog('🔄 发现已有bridge对象，直接使用');
                loadFileStructure();
            } else {
                debugError('WebChannel初始化失败');
                showError('WebChannel初始化失败');
            }
        }
    }
    
    // 等待WebChannel初始化
    function waitForBridge(callback, maxAttempts = 20) {
        let attempts = 0;
        const checkBridge = () => {
            attempts++;
            debugLog(`检查WebChannel连接状态 (${attempts}/${maxAttempts})`);
            debugLog('window.bridge: ' + (window.bridge ? 'exists' : 'undefined'));
            
            if (window.bridge && typeof window.bridge.getFileStructure === 'function') {
                debugLog('WebChannel连接成功，所有方法可用');
                callback();
            } else if (attempts < maxAttempts) {
                debugLog(`等待WebChannel连接... (${attempts}/${maxAttempts})`);
                setTimeout(checkBridge, 300);
            } else {
                debugError('WebChannel连接超时');
                const fileTree = document.getElementById('file-tree');
                if (fileTree) {
                    fileTree.innerHTML = `
                        <div class="text-center text-red-500 py-8">
                            <span class="material-icons-outlined text-4xl mb-2">error</span>
                            <p class="text-sm mb-2">WebChannel连接失败</p>
                            <button class="px-3 py-1 bg-blue-600 text-white rounded text-sm hover:bg-blue-700" onclick="location.reload()">
                                重新加载
                            </button>
                        </div>
                    `;
                }
                showError('系统初始化超时，请刷新页面重试');
            }
        };
        checkBridge();
    }
    
    // 加载文件结构
    function loadFileStructure() {
        debugLog('=' + '='.repeat(79));
        debugLog('🔍 【步骤2】前端开始加载文件结构');
        debugLog('=' + '='.repeat(79));
        
        debugLog('🔍 检查bridge对象状态:');
        debugLog('  - window.bridge存在: ' + (window.bridge ? 'YES' : 'NO'));
        debugLog('  - bridge类型: ' + typeof window.bridge);
        debugLog('  - getFileStructure方法存在: ' + (window.bridge && typeof window.bridge.getFileStructure === 'function' ? 'YES' : 'NO'));
        
        if (!window.bridge || typeof window.bridge.getFileStructure !== 'function') {
            debugError('❌ 系统接口未准备就绪');
            showError('系统接口未准备就绪，请稍后重试');
            return;
        }

        debugLog('✅ Bridge对象验证通过，准备调用getFileStructure');

        try {
            debugLog('🚀 开始调用Python的getFileStructure方法...');
            
            // Qt WebChannel的返回值可能是Promise，也可能直接是结果，或者通过回调返回
            // 这里采用最健壮的方式：优先使用回调，并检查返回值
            let handled = false;
            let callStartTime = Date.now();

            const handleData = (jsonData) => {
                if (handled) {
                    debugLog('⚠️ 数据已处理过，跳过重复处理');
                    return;
                }
                handled = true;
                
                let callEndTime = Date.now();
                debugLog('📨 【步骤2】从Python接收到数据:');
                debugLog('  - 调用耗时: ' + (callEndTime - callStartTime) + 'ms');
                debugLog('  - 数据类型: ' + typeof jsonData);
                debugLog('  - 数据长度: ' + (jsonData ? jsonData.length : 'null'));
                debugLog('  - 数据为空: ' + (!jsonData ? 'YES' : 'NO'));
                
                if (jsonData) {
                    debugLog('📄 数据预览 (前200字符):');
                    debugLog('  ' + String(jsonData).slice(0, 200) + (jsonData.length > 200 ? '...' : ''));
                }
                
                try {
                    debugLog('🔄 开始解析JSON数据...');
                    const structure = JSON.parse(jsonData);
                    debugLog('✅ JSON解析成功!');
                    debugLog('  - 结构类型: ' + typeof structure);
                    debugLog('  - 是否为数组: ' + Array.isArray(structure));
                    debugLog('  - 数组长度: ' + (Array.isArray(structure) ? structure.length : 'N/A'));
                    
                    if (Array.isArray(structure) && structure.length > 0) {
                        debugLog('📋 文件结构内容概览:');
                        structure.forEach((item, index) => {
                            debugLog(`  ${index + 1}. ${item.name} (${item.type}) - 路径: ${item.path}`);
                            if (item.type === 'folder' && item.children) {
                                debugLog(`     └─ 子项目数: ${item.children.length}`);
                            }
                        });
                    }
                    
                    debugLog('🎨 准备渲染文件树...');
                    renderFileTree(structure);
                    debugLog('✅ 【步骤2完成】文件结构传递和渲染完成');
                    
                } catch (e) {
                    debugError('❌ JSON解析失败: ' + e.message);
                    debugLog('❌ 解析失败的原始数据: ' + (jsonData ? String(jsonData).slice(0, 500) : 'null'));
                    showError('文件结构解析失败: ' + e.message);
                }
            };

            debugLog('📞 正在调用bridge.getFileStructure...');
            const result = window.bridge.getFileStructure(handleData);
            debugLog('📞 getFileStructure调用完成，返回值类型: ' + typeof result);

            // 如果返回值是Promise
            if (result && typeof result.then === 'function') {
                debugLog('🔄 检测到Promise返回值，等待异步结果...');
                result.then(data => {
                    debugLog('✅ Promise resolved，数据类型: ' + typeof data);
                    handleData(data);
                }).catch(error => {
                    debugError('❌ Promise rejected: ' + error);
                    showError('获取文件列表失败: ' + error);
                });
            } 
            // 如果直接返回了字符串
            else if (typeof result === 'string') {
                debugLog('📄 检测到直接返回字符串，长度: ' + result.length);
                handleData(result);
            }
            // 如果返回undefined或null
            else if (result === undefined || result === null) {
                debugLog('⚠️ 返回值为空，等待回调处理...');
            }
            // 其他类型
            else {
                debugLog('⚠️ 未知返回值类型: ' + typeof result + ', 值: ' + result);
            }

        } catch (e) {
            debugError('❌ 调用getFileStructure时发生异常: ' + e.message);
            debugError('❌ 异常堆栈: ' + e.stack);
            showError('调用文件列表接口失败: ' + e.message);
        }
        
        debugLog('=' + '='.repeat(79));
        debugLog('🏁 【步骤2】loadFileStructure函数执行完成');
        debugLog('=' + '='.repeat(79));
    }
    
    // 处理文件结构数据
    function handleFileStructureData(structureJson) {
        debugLog('📄 处理文件结构数据:');
        debugLog('  - 数据类型: ' + typeof structureJson);
        debugLog('  - 数据长度: ' + (structureJson ? structureJson.length : 'null'));
        
        try {
            const structure = JSON.parse(structureJson);
            debugLog('✅ JSON解析成功，结构数组长度: ' + structure.length);
            renderFileTree(structure);
        } catch (e) {
            debugError('❌ JSON解析失败: ' + e.message);
            debugLog('❌ 原始数据片段: ' + (structureJson ? String(structureJson).slice(0, 200) + '...' : 'null'));
            showError('解析文件结构失败: ' + e.message);
        }
    }
    
    // 渲染文件树
    function renderFileTree(structure) {
        debugLog('🎨 【步骤2-渲染】开始渲染文件树');
        debugLog('  - 接收到的结构类型: ' + typeof structure);
        debugLog('  - 是否为数组: ' + Array.isArray(structure));
        debugLog('  - 结构长度: ' + (structure ? structure.length : 'null'));
        
        const fileTree = document.getElementById('file-tree');
        const loadingIndicator = document.getElementById('loading-indicator');
        
        debugLog('🔍 检查DOM元素:');
        debugLog('  - fileTree元素存在: ' + (fileTree ? 'YES' : 'NO'));
        debugLog('  - loadingIndicator存在: ' + (loadingIndicator ? 'YES' : 'NO'));
        
        if (loadingIndicator) {
            loadingIndicator.remove();
            debugLog('✅ 已移除加载指示器');
        }
        
        if (structure && structure.length > 0) {
            debugLog('📋 准备构建HTML，结构概览:');
            structure.forEach((item, index) => {
                debugLog(`  ${index + 1}. ${item.name} (${item.type})`);
            });
            
            debugLog('🏗️ 开始构建树形HTML...');
            const htmlContent = buildTreeHTML(structure);
            debugLog('✅ HTML构建完成，长度: ' + htmlContent.length + ' 字符');
            debugLog('📄 HTML预览 (前300字符):');
            debugLog('  ' + htmlContent.slice(0, 300) + (htmlContent.length > 300 ? '...' : ''));
            
            debugLog('🎯 设置fileTree的innerHTML...');
            fileTree.innerHTML = htmlContent;
            debugLog('✅ 文件树DOM更新完成');
            
            // 验证渲染结果
            const renderedItems = fileTree.querySelectorAll('.file-item, .folder-item');
            debugLog('🔍 渲染验证:');
            debugLog('  - DOM中的项目数: ' + renderedItems.length);
            debugLog('  - fileTree子元素数: ' + fileTree.children.length);
            
        } else {
            debugLog('⚠️ 文件结构为空，显示空状态页面');
            fileTree.innerHTML = `
                <div class="text-center text-gray-500 py-8">
                    <span class="material-icons-outlined text-4xl mb-2 text-gray-300">folder_open</span>
                    <p class="text-sm">vault目录为空</p>
                    <button class="mt-2 px-3 py-1 bg-blue-600 text-white rounded text-sm hover:bg-blue-700" onclick="createNewNote()">
                        创建第一个笔记
                    </button>
                </div>
            `;
            debugLog('✅ 空状态页面已设置');
        }
        
        debugLog('🎉 【步骤2-渲染完成】文件树渲染流程结束');
    }
    
    // 构建树形HTML - 完全按照笔记.html的结构
    function buildTreeHTML(items, level = 0) {
        let html = '';
        items.forEach(item => {
            if (item.type === 'folder') {
                const hasChildren = item.children && item.children.length > 0;
                const expandIcon = hasChildren ? 'chevron_right' : '';
                
                html += `
                <li>
                    <div class="flex items-center p-2 rounded-md hover:bg-bg-light-gray cursor-pointer" 
                         onclick="toggleFolder(this)" 
                         oncontextmenu="showContextMenu(event, '${item.path}', 'folder')">
                        <span class="material-icons-outlined text-yellow-500 mr-2 folder-icon">folder</span>
                        <span class="text-text-dark-brown font-medium">${item.name}</span>
                        ${expandIcon ? `<span class="material-icons-outlined text-text-gray ml-auto expand-icon">${expandIcon}</span>` : ''}
                    </div>
                    ${hasChildren ? `<ul class="pl-6 mt-1 space-y-1 folder-content hidden">${buildTreeHTML(item.children, level + 1)}</ul>` : ''}
                </li>`;
            } else if (item.type === 'file') {
                html += `
                <li>
                    <div class="flex items-center p-2 rounded-md hover:bg-bg-light-gray cursor-pointer" 
                         onclick="selectFile('${item.path}', '${item.name}')"
                         oncontextmenu="showContextMenu(event, '${item.path}', 'file')">
                        <span class="material-icons-outlined text-primary mr-2">description</span>
                        <span class="text-text-medium-brown">${item.name}</span>
                    </div>
                </li>`;
            }
        });
        return html;
    }
    
    // 切换文件夹展开/折叠 - 与笔记.html保持一致
    function toggleFolder(element) {
        const content = element.nextElementSibling;
        const expandIcon = element.querySelector('.expand-icon');
        const folderIcon = element.querySelector('.folder-icon');
        
        if (content && content.classList.contains('hidden')) {
            content.classList.remove('hidden');
            if (expandIcon) expandIcon.textContent = 'expand_more';
            if (folderIcon) folderIcon.textContent = 'folder_open';
        } else if (content) {
            content.classList.add('hidden');
            if (expandIcon) expandIcon.textContent = 'chevron_right';
            if (folderIcon) folderIcon.textContent = 'folder';
        }
    }
    
    
    // 加载文件内容
    function loadFileContent(filePath) {
        if (!window.bridge) {
            showError('系统未初始化');
            return;
        }
        
        // 隐藏空状态
        document.getElementById('empty-state').classList.add('hidden');
        
        if (currentMode === 'preview') {
            // 预览模式 - 加载HTML内容
            window.bridge.loadMarkdownFile(filePath).then(function(htmlContent) {
                const previewContent = document.getElementById('preview-content');
                previewContent.innerHTML = htmlContent;
                previewContent.classList.remove('hidden');
                document.getElementById('edit-content').classList.add('hidden');
            }).catch(function(error) {
                debugError('加载预览内容失败:', error);
                showError('加载文件失败');
            });
        } else {
            // 编辑模式 - 加载原始Markdown内容
            window.bridge.loadMarkdownRaw(filePath).then(function(rawContent) {
                const editor = document.getElementById('markdown-editor');
                editor.value = rawContent;
                document.getElementById('edit-content').classList.remove('hidden');
                document.getElementById('preview-content').classList.add('hidden');
            }).catch(function(error) {
                debugError('加载编辑内容失败:', error);
                showError('加载文件失败');
            });
        }
    }
    
    // 切换到预览模式 - 与笔记.html保持一致的按钮样式
    function switchToPreview() {
        currentMode = 'preview';
        document.getElementById('preview-btn').className = 'flex items-center bg-white border border-gray-300 px-3 py-1.5 rounded-lg text-text-gray hover:bg-gray-100';
        document.getElementById('edit-btn').className = 'flex items-center bg-primary text-white px-3 py-1.5 rounded-lg hover:bg-green-600';
        
        if (currentFilePath) {
            loadFileContent(currentFilePath);
        }
    }
    
    // 切换到编辑模式 - 与笔记.html保持一致的按钮样式
    function switchToEdit() {
        currentMode = 'edit';
        document.getElementById('preview-btn').className = 'flex items-center bg-primary text-white px-3 py-1.5 rounded-lg hover:bg-green-600';
        document.getElementById('edit-btn').className = 'flex items-center bg-white border border-gray-300 px-3 py-1.5 rounded-lg text-text-gray hover:bg-gray-100';
        
        if (currentFilePath) {
            loadFileContent(currentFilePath);
        }
    }
    
    // 选择文件 - 与笔记.html保持一致
    function selectFile(filePath, fileName) {
        debugLog(`选择文件: ${fileName}`);
        
        // 更新当前文件信息
        currentFilePath = filePath;
        document.getElementById('current-file-title').textContent = fileName;
        
        // 移除之前的选中状态
        document.querySelectorAll('.file-item .flex').forEach(el => {
            el.classList.remove('bg-bg-light-green');
            el.querySelector('span:last-child').classList.remove('text-primary', 'font-semibold');
            el.querySelector('span:last-child').classList.add('text-text-medium-brown');
        });
        
        // 添加当前选中状态
        const selectedElement = document.querySelector(`[data-path="${filePath}"] .flex`);
        if (selectedElement) {
            selectedElement.classList.add('bg-bg-light-green');
            const textSpan = selectedElement.querySelector('span:last-child');
            textSpan.classList.remove('text-text-medium-brown');
            textSpan.classList.add('text-primary', 'font-semibold');
        }
        
        // 加载文件内容
        loadFileContent(filePath);
    }
    
    // 显示错误信息
    function showError(message) {
        debugError(message);
        // 这里可以添加Toast通知或其他错误显示方式
        alert('错误: ' + message);
    }
    
    // 创建新笔记
    function createNewNote() {
        debugLog('创建新笔记');
        
        waitForBridge(function() {
            // 确定创建位置
            let targetPath = 'vault';
            if (selectedTreeItem && selectedTreeItem.type === 'folder') {
                targetPath = selectedTreeItem.path;
            }
            
            window.bridge.createNewNote(targetPath).then(function(success) {
                if (success) {
                    debugLog('新笔记创建成功');
                    // 重新加载文件树
                    loadFileStructure();
                    showSuccess('新笔记创建成功');
                } else {
                    showError('创建新笔记失败');
                }
            }).catch(function(error) {
                debugError('创建新笔记失败: ' + (error && (error.message || error.toString())));
                showError('创建新笔记失败: ' + (error && error.message ? error.message : '未知错误'));
            });
        });
    }
    
    // 创建新文件夹
    function createNewFolder() {
        debugLog('创建新文件夹');
        
        waitForBridge(function() {
            // 确定创建位置
            let targetPath = 'vault';
            if (selectedTreeItem && selectedTreeItem.type === 'folder') {
                targetPath = selectedTreeItem.path;
            }
            
            window.bridge.createNewFolder(targetPath).then(function(success) {
                if (success) {
                    debugLog('新文件夹创建成功');
                    // 重新加载文件树
                    loadFileStructure();
                    showSuccess('新文件夹创建成功');
                } else {
                    showError('创建新文件夹失败');
                }
            }).catch(function(error) {
                debugError('创建新文件夹失败: ' + (error && (error.message || error.toString())));
                showError('创建新文件夹失败: ' + (error && error.message ? error.message : '未知错误'));
            });
        });
    }
    
    // 保存当前文件
    function saveCurrentFile() {
        if (!currentFilePath || currentMode !== 'edit') {
            return;
        }
        
        const editor = document.getElementById('markdown-editor');
        const content = editor.value;
        
        if (!window.bridge) {
            showError('系统未初始化');
            return;
        }
        
        window.bridge.saveMarkdownFile(currentFilePath, content).then(function(success) {
            if (success) {
                debugLog('文件保存成功');
                showSuccess('文件保存成功');
                
                // 如果当前是预览模式，重新加载预览内容
                if (currentMode === 'preview') {
                    loadFileContent(currentFilePath);
                }
            } else {
                showError('文件保存失败');
            }
        }).catch(function(error) {
            debugError('文件保存失败:', error);
            showError('文件保存失败');
        });
    }
    
    // 提取知识点
    function extractKnowledgePoints() {
        if (!currentFilePath) {
            return;
        }
        
        debugLog('提取知识点:', currentFilePath);
        
        // 显示加载状态
        const btn = document.getElementById('extract-knowledge-btn');
        const originalText = btn.innerHTML;
        btn.innerHTML = '<span class="animate-spin material-icons-outlined text-sm mr-1">refresh</span>提取中...';
        btn.disabled = true;
        
        if (window.bridge && window.bridge.extractKnowledgePoints) {
            window.bridge.extractKnowledgePoints(currentFilePath).then(function(result) {
                debugLog('知识点提取结果:', result);
                
                // 恢复按钮状态
                btn.innerHTML = originalText;
                btn.disabled = false;
                
                if (result) {
                    try {
                        const knowledgePoints = JSON.parse(result);
                        displayKnowledgePoints(knowledgePoints);
                    } catch (e) {
                    }
                } else {
                }
            }).catch(function(error) {
            });
        } else {
            btn.innerHTML = originalText;
            btn.disabled = false;
        }
    }
    
    // 显示知识点
    function displayKnowledgePoints(knowledgePoints) {
        const container = document.getElementById('knowledge-points');
        const noPointsMsg = document.getElementById('no-knowledge-points');
        
        if (noPointsMsg) {
            noPointsMsg.remove();
        }
        
        if (!knowledgePoints || knowledgePoints.length === 0) {
            container.innerHTML = `
                <div class="text-center text-gray-500 py-8">
                    <span class="material-icons-outlined text-4xl mb-2 text-gray-300">lightbulb_outline</span>
                    <p class="text-sm">未找到知识点</p>
                </div>
            `;
            return;
        }
        
        let html = '';
        knowledgePoints.forEach((point, index) => {
            html += `
                <div class="knowledge-card bg-gradient-to-r from-purple-50 to-blue-50 border border-purple-200 rounded-lg p-3 cursor-pointer">
                    <div class="flex items-start justify-between">
                        <div class="flex-1">
                            <h4 class="font-semibold text-gray-800 text-sm mb-1">${point.title || `知识点 ${index + 1}`}</h4>
                            <p class="text-xs text-gray-600 leading-relaxed">${point.content || point.description || '暂无描述'}</p>
                        </div>
                        <div class="ml-2 flex space-x-1 opacity-0 group-hover:opacity-100 transition-opacity">
                            <button class="text-gray-400 hover:text-blue-600 text-xs" title="编辑" onclick="editKnowledgePoint(${index})">
                                <span class="material-icons-outlined" style="font-size: 14px;">edit</span>
                            </button>
                            <button class="text-gray-400 hover:text-red-600 text-xs" title="删除" onclick="deleteKnowledgePoint(${index})">
                                <span class="material-icons-outlined" style="font-size: 14px;">delete</span>
                            </button>
                        </div>
                    </div>
                    ${point.keywords ? `
                        <div class="mt-2 flex flex-wrap gap-1">
                            ${point.keywords.map(keyword => `
                                <span class="px-2 py-1 bg-purple-100 text-purple-700 text-xs rounded-full">${keyword}</span>
                            `).join('')}
                        </div>
                    ` : ''}
                </div>
            `;
        });
        
        container.innerHTML = html;
    }
    
    // 显示成功消息
    function showSuccess(message) {
        showToast(message, 'success');
    }
    
    // 显示错误消息
    function showError(message) {
        showToast(message, 'error');
    }
    
    // 显示提示消息
    function showToast(message, type = 'info') {
        // 创建toast元素
        const toast = document.createElement('div');
        toast.className = `fixed top-4 right-4 px-4 py-2 rounded-lg text-white text-sm font-medium z-50 transform transition-all duration-300 translate-x-full opacity-0`;
        
        if (type === 'success') {
            toast.classList.add('bg-green-600');
        } else if (type === 'error') {
            toast.classList.add('bg-red-600');
        } else {
            toast.classList.add('bg-blue-600');
        }
        
        toast.textContent = message;
        document.body.appendChild(toast);
        
        // 显示动画
        setTimeout(() => {
            toast.classList.remove('translate-x-full', 'opacity-0');
        }, 100);
        
        // 自动隐藏
        setTimeout(() => {
            toast.classList.add('translate-x-full', 'opacity-0');
            setTimeout(() => {
                if (toast.parentNode) {
                    toast.parentNode.removeChild(toast);
                }
            }, 300);
        }, 3000);
    }
    
    // 拖放功能变量
    let draggedElement = null;
    let draggedPath = null;
    let draggedType = null;
    
    // 添加拖放事件监听
    function addDragDropListeners() {
        // 为所有文件和文件夹项添加拖放功能
        document.querySelectorAll('.file-item, .folder-item').forEach(item => {
            const element = item.querySelector('.flex');
            if (element) {
                element.draggable = true;
                element.addEventListener('dragstart', handleDragStart);
                element.addEventListener('dragend', handleDragEnd);
            }
        });
        
        // 为文件夹添加拖放目标功能
        document.querySelectorAll('.folder-item').forEach(folder => {
            const element = folder.querySelector('.flex');
            if (element) {
                element.addEventListener('dragover', handleDragOver);
                element.addEventListener('drop', handleDrop);
                element.addEventListener('dragenter', handleDragEnter);
                element.addEventListener('dragleave', handleDragLeave);
            }
        });
    }
    
    
    // 拖拽悬停
    function handleDragOver(event) {
        event.preventDefault();
        event.dataTransfer.dropEffect = 'move';
    }
    
    // 拖拽进入
    function handleDragEnter(event) {
        event.preventDefault();
        const targetItem = event.currentTarget.closest('.folder-item');
        if (targetItem && targetItem.dataset.path !== draggedPath) {
            event.currentTarget.classList.add('drag-over', 'bg-green-100', 'border-green-300');
        }
    }
    
    // 拖拽离开
    function handleDragLeave(event) {
        // 检查是否真的离开了目标区域
        const rect = event.currentTarget.getBoundingClientRect();
        const x = event.clientX;
        const y = event.clientY;
        
        if (x < rect.left || x > rect.right || y < rect.top || y > rect.bottom) {
            event.currentTarget.classList.remove('drag-over', 'bg-green-100', 'border-green-300');
        }
    }
    
    // 拖拽放下
    function handleDrop(event) {
        event.preventDefault();
        
        const targetItem = event.currentTarget.closest('.folder-item');
        const targetPath = targetItem.dataset.path;
        
        // 移除拖放样式
        event.currentTarget.classList.remove('drag-over', 'bg-green-100', 'border-green-300');
        
        if (draggedPath && targetPath && draggedPath !== targetPath) {
            debugLog('移动文件:', draggedPath, '到', targetPath);
            moveFileOrFolder(draggedPath, targetPath);
        }
    }
    
    // 移动文件或文件夹
    function moveFileOrFolder(sourcePath, targetPath) {
        if (!window.bridge || !window.bridge.moveFileOrFolder) {
            showError('移动功能不可用');
            return;
        }
        
        window.bridge.moveFileOrFolder(sourcePath, targetPath).then(function(success) {
            if (success) {
                debugLog('文件移动成功');
                showSuccess('文件移动成功');
                // 重新加载文件树
                loadFileStructure();
            } else {
                showError('文件移动失败');
            }
        }).catch(function(error) {
            debugError('文件移动失败:', error);
            showError('文件移动失败');
        });
    }
    
    // 右键菜单功能
    function showContextMenu(event, path, type) {
        event.preventDefault();
        
        // 移除现有的右键菜单
        const existingMenu = document.getElementById('context-menu');
        if (existingMenu) {
            existingMenu.remove();
        }
        
        // 创建右键菜单
        const menu = document.createElement('div');
        menu.id = 'context-menu';
        menu.className = 'fixed bg-white border border-gray-200 rounded-lg shadow-lg py-2 z-50';
        menu.style.left = event.pageX + 'px';
        menu.style.top = event.pageY + 'px';
        
        const menuItems = [
            { text: '重命名', icon: 'edit', action: () => showRenameDialog(path, type) },
            { text: '删除', icon: 'delete', action: () => showDeleteDialog(path, type) },
            { text: '---', divider: true },
            { text: '新建笔记', icon: 'note_add', action: () => createNewNote(type === 'folder' ? path : path.substring(0, path.lastIndexOf('/'))) },
            { text: '新建文件夹', icon: 'create_new_folder', action: () => createNewFolder(type === 'folder' ? path : path.substring(0, path.lastIndexOf('/'))) }
        ];
        
        menuItems.forEach(item => {
            if (item.divider) {
                const divider = document.createElement('div');
                divider.className = 'border-t border-gray-200 my-1';
                menu.appendChild(divider);
            } else {
                const menuItem = document.createElement('div');
                menuItem.className = 'flex items-center px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 cursor-pointer';
                menuItem.innerHTML = `
                    <span class="material-icons-outlined text-sm mr-2">${item.icon}</span>
                    ${item.text}
                `;
                menuItem.onclick = () => {
                    item.action();
                    menu.remove();
                };
                menu.appendChild(menuItem);
            }
        });
        
        document.body.appendChild(menu);
        
        // 点击其他地方关闭菜单
        setTimeout(() => {
            document.addEventListener('click', function closeMenu() {
                menu.remove();
                document.removeEventListener('click', closeMenu);
            });
        }, 100);
    }
    
    // 显示重命名对话框
    function showRenameDialog(path, type) {
        const fileName = path.split('/').pop();
        const newName = prompt(`重命名${type === 'folder' ? '文件夹' : '文件'}:`, fileName);
        
        if (newName && newName !== fileName) {
            renameFileOrFolder(path, newName);
        }
    }
    
    // 重命名文件或文件夹
    function renameFileOrFolder(oldPath, newName) {
        if (!window.bridge || !window.bridge.renameFileOrFolder) {
            showError('重命名功能不可用');
            return;
        }
        
        window.bridge.renameFileOrFolder(oldPath, newName).then(function(success) {
            if (success) {
                debugLog('重命名成功');
                showSuccess('重命名成功');
                // 重新加载文件树
                loadFileStructure();
            } else {
                showError('重命名失败，可能文件名已存在');
            }
        }).catch(function(error) {
            debugError('重命名失败:', error);
            showError('重命名失败');
        });
    }
    
    // 显示删除确认对话框
    function showDeleteDialog(path, type) {
        const fileName = path.split('/').pop();
        const confirmed = confirm(`确定要删除${type === 'folder' ? '文件夹' : '文件'} "${fileName}" 吗？\n\n此操作不可撤销！`);
        
        if (confirmed) {
            deleteFileOrFolder(path);
        }
    }
    
    // 删除文件或文件夹
    function deleteFileOrFolder(path) {
        if (!window.bridge || !window.bridge.deleteFileOrFolder) {
            showError('删除功能不可用');
            return;
        }
        
        window.bridge.deleteFileOrFolder(path).then(function(success) {
            if (success) {
                debugLog('删除成功');
                showSuccess('删除成功');
                // 如果删除的是当前打开的文件，清空内容区
                if (currentFilePath === path) {
                    currentFilePath = null;
                    document.getElementById('current-file-title').textContent = '选择文件开始学习';
                    document.getElementById('empty-state').classList.remove('hidden');
                    document.getElementById('preview-content').classList.add('hidden');
                    document.getElementById('edit-content').classList.add('hidden');
                    document.getElementById('extract-knowledge-btn').disabled = true;
                    document.getElementById('save-btn').disabled = true;
                }
                // 重新加载文件树
                loadFileStructure();
            } else {
                showError('删除失败');
            }
        }).catch(function(error) {
            debugError('删除失败:', error);
            showError('删除失败');
        });
    }
    
    // 知识点管理功能
    let currentKnowledgePoints = [];
    
    // 编辑知识点
    function editKnowledgePoint(index) {
        const point = currentKnowledgePoints[index];
        const newTitle = prompt('编辑知识点标题:', point.title || '');
        if (newTitle !== null && newTitle !== point.title) {
            currentKnowledgePoints[index].title = newTitle;
            displayKnowledgePoints(currentKnowledgePoints);
            showSuccess('知识点已更新');
        }
    }
    
    // 删除知识点
    function deleteKnowledgePoint(index) {
        const point = currentKnowledgePoints[index];
        const confirmed = confirm(`确定要删除知识点 "${point.title || '未命名'}" 吗？`);
        if (confirmed) {
            currentKnowledgePoints.splice(index, 1);
            displayKnowledgePoints(currentKnowledgePoints);
            showSuccess('知识点已删除');
        }
    }
    
    // 更新显示知识点函数，保存当前数据
    const originalDisplayKnowledgePoints = displayKnowledgePoints;
    displayKnowledgePoints = function(knowledgePoints) {
        currentKnowledgePoints = knowledgePoints || [];
        originalDisplayKnowledgePoints(knowledgePoints);
    };
    
    // 优化拖拽样式
    function handleDragStart(event) {
        draggedElement = event.currentTarget;
        const item = draggedElement.closest('.file-item, .folder-item');
        draggedPath = item.dataset.path;
        draggedType = item.classList.contains('file-item') ? 'file' : 'folder';
        
        // 设置拖拽效果
        event.dataTransfer.effectAllowed = 'move';
        event.dataTransfer.setData('text/plain', draggedPath);
        
        // 添加拖拽样式
        draggedElement.classList.add('dragging');
        
        debugLog('开始拖拽:', draggedPath, draggedType);
    }
    
    // 优化拖拽结束
    function handleDragEnd(event) {
        // 移除拖拽样式
        if (draggedElement) {
            draggedElement.classList.remove('dragging');
        }
        
        // 清理拖放目标样式
        document.querySelectorAll('.drag-over').forEach(el => {
            el.classList.remove('drag-over');
        });
        
        draggedElement = null;
        draggedPath = null;
        draggedType = null;
    }
    
    // 优化文件选择
    function selectFile(filePath, fileName) {
        debugLog('选择文件:', filePath);
        
        // 更新选中状态
        document.querySelectorAll('.file-item .flex, .folder-item .flex').forEach(el => {
            el.classList.remove('selected');
        });
        
        const selectedElement = document.querySelector(`[data-path="${filePath}"] .flex`);
        if (selectedElement) {
            selectedElement.classList.add('selected');
        }
        
        currentFilePath = filePath;
        
        // 更新标题
        document.getElementById('current-file-title').textContent = fileName;
        
        // 启用按钮
        document.getElementById('extract-knowledge-btn').disabled = false;
        document.getElementById('save-btn').disabled = false;
        
        // 加载文件内容
        loadFileContent(filePath);
    }
    
    // 添加键盘快捷键支持
    document.addEventListener('keydown', function(event) {
        // Ctrl+S 保存文件
        if (event.ctrlKey && event.key === 's') {
            event.preventDefault();
            if (currentFilePath && currentMode === 'edit') {
                saveCurrentFile();
            }
        }
        
        // Ctrl+N 新建笔记
        if (event.ctrlKey && event.key === 'n') {
            event.preventDefault();
            createNewNote();
        }
        
        // F2 重命名（如果有选中的文件）
        if (event.key === 'F2' && currentFilePath) {
            event.preventDefault();
            const fileName = currentFilePath.split('/').pop();
            showRenameDialog(currentFilePath, currentFilePath.includes('.') ? 'file' : 'folder');
        }
    });
    
    // 创建新文件夹
    function createNewFolder() {
        debugLog('创建新文件夹');
        
        if (!window.bridge) {
            showError('系统未初始化');
            return;
        }
        
        const folderName = prompt('请输入文件夹名称:', '新文件夹');
        if (folderName) {
            window.bridge.createNewFolder(folderName).then(function(result) {
                debugLog('文件夹创建成功');
                loadFileStructure(); // 重新加载文件树
            }).catch(function(error) {
                debugError('创建文件夹失败:', error);
                showError('创建文件夹失败');
            });
        }
    }
    
    // 保存Markdown文件
    function saveMarkdownFile() {
        if (!currentFilePath || !window.bridge) {
            showError('无法保存文件');
            return;
        }
        
        const content = document.getElementById('markdown-editor').value;
        window.bridge.saveMarkdownFile(currentFilePath, content).then(function(result) {
            debugLog('文件保存成功');
            // 如果当前是预览模式，重新加载预览内容
            if (currentMode === 'preview') {
                loadFileContent(currentFilePath);
            }
        }).catch(function(error) {
            debugError('保存文件失败:', error);
            showError('保存文件失败');
        });
    }
    
    // 右键菜单功能（占位符）
    function showContextMenu(event, path, type) {
        event.preventDefault();
        debugLog(`右键菜单: ${type} - ${path}`);
        // 这里可以实现右键菜单功能
    }
    
    // 显示错误信息
    function showError(message) {
        debugError(message);
        alert('错误: ' + message);
    }
    
    // 更新渲染文件树函数，添加拖放监听
    
    })(); // IIFE结束
</script>
